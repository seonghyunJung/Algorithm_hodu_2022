알고리즘에 대한 설명

이 알고리즘은 음료를 주문한 순서, 음료를 받을 팀의 정보 등을 고려하지 않은, 순수하게 음료를 만드는 시간을 단축시키기 위한 알고리즘 입니다.
즉 하나의 케이스 내에서 모든 음료의 정보를 한꺼번에 분석하여 최대의 시간적 효율을 내지만, 음료의 질이나 손님의 대기 효율은 고려하지 않았습니다.



코드 설명

먼저 해당 알고리즘의 기본적인 원리에 대해 설명하겠습니다.
알고리즘의 기본적인 원리는 음료별로 무슨 동작을 수행해야 하는지를 계속해서 업데이트 하여, 기계동작의 우선순위를 높여 최대한 기계가 쉬지 않고 돌아갈 수 있도록 하는 것입니다.
모든 기계가 꽉찼거나 기계작업이 존재하지 않는다면, 모든 음료에 대해 사람이 할 수 있는 작업을 한 바퀴 돌려 기계를 기다리는 시간에 효율적으로 작업을 할 수 있도록 하였습니다.
특수한 경우로, 기계를 기다려야 하는데 사람이 할 수 있는 작업이 존재하지 않는다면 기계를 기다릴 수 있게 하였습니다.

본격적인 코드의 설명에 앞서, 이 알고리즘은 3개의 boolean flag와 3개의 임시list를 이용하여 만들었습니다.
3개의 flag는 현재 상태에서 기계동작이 존재하는지를 확인하는 flag1, 사람동작이 존재하는지를 확인하는 flag2, 기계동작이 실행됐는지를 확인하는 flag3으로 이루어져 있습니다. 모든 flag의 기본값은 False입니다.
3개의 임시 list는 현재의 음료 별 step을 기록하는 currentOrder[], 기계동작의 index를 모아놓은 machineOrder[], 사람동작의 index를 모아놓은 personOrder[]으로 이루어져 있습니다.

먼저 while문 밖에 order[]에 주문받은 음료들을 넣습니다.

이 알고리즘의 모든 동작은 while문이 감싸고 있습니다. while문은 주문한 음료들이 들어있는 order배열이 빌 때까지 계속 돌아갑니다.
한번 while문이 돌 때마다, currentOrder[]에 order의 현재 수행해야 하는 동작을 모두 기록합니다.

그 후  currentOrder[]내 원소의 타입을 확인하여, 기계가 필요한 작업은 machineOrder[]에, 사람이 직접 하는 작업은 personOrder[]에 count를 이용하여 order의 index를 저장합니다.

이렇게 음료 별 기계동작과 사람동작을 먼저 구분지어 놓습니다.

다음으로 flag1과 flag2를 설정합니다. machineOrder[]의 길이가 0이 아니라면 flag1을 True로, personOrder[]의 길이가 0이 아니라면 flag2를 True로 설정합니다.

이제 앞서 구한 정보들을 이용해 작업을 진행하는 부분이 시작됩니다.
먼저 flag1을 확인하여 기계 동작이 존재하는지를 확인합니다. 만약 기계동작이 존재한다면, machineOrder[]에 저장된 index를 이용하여 for문으로 모든 기계작업이 수행가능한지 확인합니다.
수행 가능한 기계작업이 존재한다면 flag3을 True로 만들고, 그 즉시 for문을 빠져나옵니다. 만약 기계작업이 수행 불가능하다면 continue를 이용하여 다음 기계작업을 확인하고, 모든 기계작업이 수행 불가능하면 그냥 빠져나옵니다.

다음으로는 flag3을 확인하여 기계동작이 수행됐는지를 확인합니다. 기계동작이 진행됐다면, while문 처음으로 돌아가서 다시 현재 step을 업데이트하도록 합니다.
기계동작이 수행되지 않았다면, flag2를 확인하여 사람작업이 존재하는지를 확인합니다. 사람작업이 존재하지 않는다면 할 수 없이 가장 빨리 끝나는 기계작업이 끝날 때까지 대기합니다.
사람작업이 존재한다면, for문을 이용해 해당 시기의 모든 사람 작업을 실행합니다. 이 때 기계도 자동으로 돌아가고 있기 때문에 효율적으로 시간을 쓸 수 있습니다.